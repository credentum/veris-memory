version: "3.8"

services:
  # Context Store MCP Server (Primary AI Agent Interface)
  context-store:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile
    ports:
      - "8000:8000"
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - NEO4J_RO_PASSWORD=${NEO4J_RO_PASSWORD:-readonly_secure_2024!}
      - REDIS_URL=redis://redis:6379
      - MCP_SERVER_PORT=8000
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
      - AUTH_REQUIRED=${AUTH_REQUIRED:-true}
      - ENVIRONMENT=${ENVIRONMENT:-development}
      # PR #170: Cache and embedding configuration
      - VERIS_CACHE_TTL_SECONDS=${VERIS_CACHE_TTL_SECONDS:-300}
      - STRICT_EMBEDDINGS=${STRICT_EMBEDDINGS:-false}
      - EMBEDDING_DIM=${EMBEDDING_DIM:-384}  # v1.0 compliance: must be 384
      - QDRANT_COLLECTION_NAME=${QDRANT_COLLECTION_NAME:-context_embeddings}  # Collection name for vector storage
    command: ["python", "-m", "uvicorn", "src.mcp_server.main:app", "--host", "0.0.0.0", "--port", "8000"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - context-store-network

  # REST API Server (Operational Interface & Monitoring)
  api:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.api
    ports:
      - "8001:8001"
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - NEO4J_RO_PASSWORD=${NEO4J_RO_PASSWORD:-readonly_secure_2024!}
      - REDIS_URL=redis://redis:6379
      - API_SERVER_PORT=8001
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
    command: ["python", "-m", "uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8001"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/api/v1/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - context-store-network

  # Vector Database (Qdrant) - Using v1.15.1 with health check tools
  qdrant:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.qdrant
    image: veris-memory/qdrant:v1.15.1-healthcheck
    platform: linux/amd64
    ports:
      - "6333:6333"
      - "6334:6334" # gRPC port
    volumes:
      - qdrant_data:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    networks:
      - context-store-network

  # Graph Database (Neo4j)
  neo4j:
    image: neo4j:5.15-community@sha256:69c579facb7acab1e98f28952b91144c89e469a081804a5dafebd6c3030433b8
    platform: linux/amd64
    ports:
      - "7474:7474" # HTTP
      - "7687:7687" # Bolt
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      # Mount initialization scripts for schema setup
      - ./deployments/neo4j-init:/docker-entrypoint-initdb.d:ro
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_dbms_default__listen__address=0.0.0.0
      - NEO4J_dbms_default__advertised__address=localhost
      - NEO4J_dbms_connector_https_advertised__address=localhost:7473
      - NEO4J_dbms_connector_http_advertised__address=localhost:7474
      - NEO4J_dbms_connector_bolt_advertised__address=localhost:7687
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
      # Enable Neo4j Labs plugins for advanced features
      - NEO4JLABS_PLUGINS=["apoc"]
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:7474",
        ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    restart: unless-stopped
    networks:
      - context-store-network

  # Cache/KV Store (Redis)
  redis:
    image: redis:7.2.5-alpine@sha256:6aaf3f5e6bc8a592fbfe2cccf19eb36d27c39d12dab4f4b01556b7449e7b1f44
    platform: linux/amd64
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    networks:
      - context-store-network

  # Monitoring Dashboard Service
  monitoring-dashboard:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile
    ports:
      - "8080:8080"
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://redis:6379
      - DASHBOARD_PORT=8080
      - MONITORING_ENABLED=true
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
    command: ["python", "-m", "src.monitoring"]
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/dashboard/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 90s
    restart: unless-stopped
    networks:
      - context-store-network

  # Sentinel Monitoring Service - Monitors all S1-S10 checks and sends alerts
  # Requires TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID to be set in GitHub Secrets
  # for Telegram alerting. Get bot token from @BotFather, chat ID from @userinfobot
  sentinel:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.sentinel
    environment:
      # Telegram Configuration (from GitHub Secrets)
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - TELEGRAM_CHAT_ID=${TELEGRAM_CHAT_ID}
      # Sentinel Configuration
      - SENTINEL_CHECK_INTERVAL=60
      - TARGET_BASE_URL=http://context-store:8000  # Changed from SENTINEL_TARGET_URL to match code
      - SENTINEL_API_URL=http://api:8001  # Deprecated, kept for backwards compatibility
      # Service URLs - using consistent naming with other services
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://redis:6379
      - QDRANT_URL=http://qdrant:6333
      - MONITORING_DASHBOARD_URL=http://monitoring-dashboard:8080
      # API Authentication - Sentinel uses its own dedicated API key
      - SENTINEL_API_KEY=${SENTINEL_API_KEY}
    volumes:
      - sentinel_data:/var/lib/sentinel
    ports:
      - "9090:9090"
    depends_on:
      context-store:
        condition: service_healthy
      api:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      redis:
        condition: service_healthy
      monitoring-dashboard:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/health"]
      interval: 60s      # Less frequent to reduce load
      timeout: 5s       # Faster timeout
      retries: 5        # More retries for resilience
      start_period: 120s # Longer startup grace period
    restart: unless-stopped
    networks:
      - context-store-network

  # TeamAI Voice Platform Services
  # LiveKit Server for Real-Time Voice (local development/testing)
  # Note: Production uses LiveKit Cloud (LIVEKIT_API_WEBSOCKET)
  livekit:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.livekit
    image: veris-memory/livekit:latest-healthcheck
    container_name: livekit-server
    ports:
      - "7880:7880"  # WebRTC/HTTP API (matches config.yaml)
      - "7882:7882"  # Metrics
      - "3478:3478/udp"  # TURN UDP (matches config.yaml udp_port)
      - "5349:5349"  # TURN TLS (matches config.yaml tls_port)
    environment:
      - "LIVEKIT_KEYS=${LIVEKIT_API_KEY}: ${LIVEKIT_API_SECRET}"
      - LIVEKIT_WEBHOOK_URLS=${LIVEKIT_WEBHOOK_URLS:-}
    volumes:
      - ./docker/livekit/config.yaml:/etc/livekit.yaml:ro
    networks:
      - context-store-network
      - voice-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7880"]
      interval: 20s
      timeout: 3s
      retries: 5
      start_period: 30s

  # Voice Bot Service - Integrates LiveKit with MCP Memory
  voice-bot:
    build:
      context: ./voice-bot
      dockerfile: Dockerfile
    container_name: voice-bot
    environment:
      # LiveKit Configuration (Cloud or Self-Hosted)
      - LIVEKIT_URL=${LIVEKIT_API_WEBSOCKET:-ws://livekit:7880}
      - LIVEKIT_API_KEY=${LIVEKIT_API_KEY}
      - LIVEKIT_API_SECRET=${LIVEKIT_API_SECRET}

      # MCP Server Connection (Sprint 13 compatible)
      - MCP_SERVER_URL=http://context-store:8000
      - MCP_API_KEY=${API_KEY_VOICEBOT}
      - VOICE_BOT_AUTHOR_PREFIX=${VOICE_BOT_AUTHOR_PREFIX:-voice_bot}
      - ENABLE_MCP_RETRY=${ENABLE_MCP_RETRY:-true}
      - MCP_RETRY_ATTEMPTS=${MCP_RETRY_ATTEMPTS:-3}

      # Redis for Session State
      - REDIS_URL=redis://redis:6379

      # Service Configuration
      - SERVICE_NAME=voice-bot
      - HOST=0.0.0.0
      - PORT=8002
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - CORS_ORIGINS=${CORS_ORIGINS:-*}

      # Voice Configuration (OpenAI Whisper + TTS)
      - STT_PROVIDER=${STT_PROVIDER:-whisper}
      - TTS_PROVIDER=${TTS_PROVIDER:-openai}
      - STT_API_KEY=${STT_API_KEY:-}
      - TTS_API_KEY=${TTS_API_KEY:-}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}

      # Feature Flags
      - ENABLE_VOICE_COMMANDS=${ENABLE_VOICE_COMMANDS:-true}
      - ENABLE_FACT_STORAGE=${ENABLE_FACT_STORAGE:-true}
      - ENABLE_CONVERSATION_TRACE=${ENABLE_CONVERSATION_TRACE:-true}
    ports:
      - "8002:8002"
    depends_on:
      context-store:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - context-store-network
      - voice-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    volumes:
      - ./voice-bot/app:/app/app:ro
      - voice-bot-logs:/app/logs

volumes:
  qdrant_data:
    driver: local
  neo4j_data:
    driver: local
  neo4j_logs:
    driver: local
  redis_data:
    driver: local
  sentinel_data:
    driver: local
  voice-bot-logs:
    driver: local

networks:
  context-store-network:
    driver: bridge
    name: veris-memory-dev_context-store-network
  voice-network:
    driver: bridge
    name: veris-memory-dev_voice-network
