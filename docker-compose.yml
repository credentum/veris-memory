
services:
  # Context Store MCP Server (Primary AI Agent Interface)
  context-store:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile
    ports:
      - "8000:8000"  # SECURITY: Accessible via Docker bridge network for MCP clients (external access blocked by firewall)
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - NEO4J_RO_PASSWORD=${NEO4J_RO_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - MCP_SERVER_PORT=8000
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
      - API_KEY_SENTINEL=${SENTINEL_API_KEY}
      - AUTH_REQUIRED=${AUTH_REQUIRED:-true}
      - ENVIRONMENT=${ENVIRONMENT:-development}
      # PR #170: Cache and embedding configuration
      - VERIS_CACHE_TTL_SECONDS=${VERIS_CACHE_TTL_SECONDS:-300}
      - STRICT_EMBEDDINGS=${STRICT_EMBEDDINGS:-false}
      - EMBEDDING_DIM=${EMBEDDING_DIM:-384}  # v1.0 compliance: must be 384
      - QDRANT_COLLECTION_NAME=${QDRANT_COLLECTION_NAME:-context_embeddings}  # Collection name for vector storage
    command: ["python", "-m", "uvicorn", "src.mcp_server.main:app", "--host", "0.0.0.0", "--port", "8000"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - context-store-network

  # REST API Server (Operational Interface & Monitoring)
  api:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.api
    ports:
      - "127.0.0.1:8001:8001"  # SECURITY: Bind to localhost only
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - NEO4J_RO_PASSWORD=${NEO4J_RO_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - API_SERVER_PORT=8001
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
    command: ["python", "-m", "uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8001"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/api/v1/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - context-store-network

  # Vector Database (Qdrant) - Using v1.15.1 with health check tools
  qdrant:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.qdrant
    image: veris-memory/qdrant:v1.15.1-healthcheck
    platform: linux/amd64
    ports:
      - "127.0.0.1:6333:6333"  # SECURITY: Bind to localhost only
      - "127.0.0.1:6334:6334"  # SECURITY: gRPC port - localhost only
    volumes:
      - qdrant_data:/qdrant/storage
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped
    networks:
      - context-store-network

  # Graph Database (Neo4j)
  neo4j:
    image: neo4j:5.15-community@sha256:69c579facb7acab1e98f28952b91144c89e469a081804a5dafebd6c3030433b8
    platform: linux/amd64
    ports:
      - "127.0.0.1:7474:7474"  # SECURITY: HTTP - localhost only
      - "127.0.0.1:7687:7687"  # SECURITY: Bolt - localhost only
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      # Mount initialization scripts for schema setup
      - ./deployments/neo4j-init:/docker-entrypoint-initdb.d:ro
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_dbms_default__listen__address=0.0.0.0
      - NEO4J_dbms_default__advertised__address=localhost
      - NEO4J_dbms_connector_https_advertised__address=localhost:7473
      - NEO4J_dbms_connector_http_advertised__address=localhost:7474
      - NEO4J_dbms_connector_bolt_advertised__address=localhost:7687
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
      # Enable Neo4j Labs plugins for advanced features
      - NEO4JLABS_PLUGINS=["apoc"]
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:7474",
        ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    restart: unless-stopped
    networks:
      - context-store-network

  # Cache/KV Store (Redis)
  redis:
    image: redis:7.2.5-alpine@sha256:6aaf3f5e6bc8a592fbfe2cccf19eb36d27c39d12dab4f4b01556b7449e7b1f44
    platform: linux/amd64
    ports:
      - "127.0.0.1:6379:6379"  # SECURITY: Bind to localhost only
    volumes:
      - redis_data:/data
    # SECURITY: Redis with password authentication
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --protected-mode yes
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    networks:
      - context-store-network

  # Monitoring Dashboard Service
  monitoring-dashboard:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile
    ports:
      - "127.0.0.1:8080:8080"  # SECURITY: Bind to localhost only
    environment:
      - QDRANT_URL=http://qdrant:6333
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - DASHBOARD_PORT=8080
      - MONITORING_ENABLED=true
      - LOG_LEVEL=info
      - API_KEY_MCP=${API_KEY_MCP}
    command: ["python", "-m", "src.monitoring"]
    depends_on:
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/dashboard/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 90s
    restart: unless-stopped
    networks:
      - context-store-network

  # Sentinel Monitoring Service - Monitors all S1-S10 checks and sends alerts
  # Requires TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID to be set in GitHub Secrets
  # for Telegram alerting. Get bot token from @BotFather, chat ID from @userinfobot
  sentinel:
    build:
      context: .
      dockerfile: dockerfiles/Dockerfile.sentinel
    environment:
      # Telegram Configuration (from GitHub Secrets)
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - TELEGRAM_CHAT_ID=${TELEGRAM_CHAT_ID}
      # Sentinel Configuration
      - SENTINEL_CHECK_INTERVAL=60
      - TARGET_BASE_URL=http://context-store:8000  # Changed from SENTINEL_TARGET_URL to match code
      - SENTINEL_API_URL=http://api:8001  # Deprecated, kept for backwards compatibility
      # Service URLs - using consistent naming with other services
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379  # SECURITY: Redis with password auth
      - QDRANT_URL=http://qdrant:6333
      - MONITORING_DASHBOARD_URL=http://monitoring-dashboard:8080
      # API Authentication - Sentinel uses its own dedicated API key
      - SENTINEL_API_KEY=${SENTINEL_API_KEY}
      # General Configuration (required for S7 config parity check)
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - ENVIRONMENT=${ENVIRONMENT:-production}
    volumes:
      - sentinel_data:/var/lib/sentinel
      # Mount host backup directories for S6 backup validation (read-only)
      # IMPORTANT: These directories must exist on the host for sentinel to validate backups
      # If directories don't exist, sentinel S6 check will fail
      # To create directories: mkdir -p /backup /opt/veris-memory-backups
      # For custom paths, set environment variable: S6_BACKUP_PATHS=/custom/path
      - /backup:/backup:ro
      - /opt/veris-memory-backups:/opt/veris-memory-backups:ro
    ports:
      - "127.0.0.1:9090:9090"  # SECURITY: Bind to localhost only
    depends_on:
      context-store:
        condition: service_healthy
      api:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      redis:
        condition: service_healthy
      monitoring-dashboard:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/health"]
      interval: 60s      # Less frequent to reduce load
      timeout: 5s       # Faster timeout
      retries: 5        # More retries for resilience
      start_period: 120s # Longer startup grace period
    restart: unless-stopped
    networks:
      - context-store-network

  # Voice Platform Services
  # NOTE: livekit and voice-bot services are defined in docker-compose.voice.yml
  # This prevents port binding conflicts when using -f flag with multiple compose files

volumes:
  qdrant_data:
    driver: local
  neo4j_data:
    driver: local
  neo4j_logs:
    driver: local
  redis_data:
    driver: local
  sentinel_data:
    driver: local
  # voice-bot-logs volume is defined in docker-compose.voice.yml

networks:
  context-store-network:
    driver: bridge
    name: veris-memory-dev_context-store-network
  # voice-network is defined in docker-compose.voice.yml
