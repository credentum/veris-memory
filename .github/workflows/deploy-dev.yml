name: Deploy to Development Environment

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'schemas/**'
      - 'contracts/**'
      - 'requirements.txt'
      - 'dockerfiles/Dockerfile*'
      - 'docker-compose*.yml'
      - '.env*'
      - '.github/workflows/deploy-dev.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

jobs:
  deploy-dev:
    name: Deploy to Dev Environment
    runs-on: ubuntu-latest
    environment: development
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          # Mask secrets in logs
          echo "::add-mask::${{ secrets.HETZNER_SSH_KEY }}"
          echo "::add-mask::${{ secrets.NEO4J_PASSWORD }}"
          echo "::add-mask::${{ secrets.TELEGRAM_BOT_TOKEN }}"
          echo "::add-mask::${{ secrets.TELEGRAM_CHAT_ID }}"
          
          # Create SSH key with secure permissions
          # Use printf to preserve newlines in the key
          printf '%s\n' "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # Add SSH host to known hosts to avoid prompt
          ssh-keyscan -t ed25519 -H ${{ secrets.HETZNER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH key format
          if ! ssh-keygen -l -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "Error: Invalid SSH key format"
            exit 1
          fi

      - name: Deploy to Dev Environment
        run: |
          # SIMPLE PASSWORD HANDLING:
          # ========================
          # Store the password as PLAIN TEXT in GitHub Secrets
          # GitHub Secrets are already encrypted and secure
          # No need for base64 encoding - it just adds complexity
          
          # Verify the secret exists
          if [ -z '${{ secrets.NEO4J_PASSWORD }}' ]; then
            echo "‚ùå ERROR: NEO4J_PASSWORD secret is not set in GitHub Actions!"
            echo "Please set the NEO4J_PASSWORD secret in: Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi
          
          echo "‚úÖ NEO4J_PASSWORD secret exists in GitHub Actions"
          
          # Pass the password directly to the remote server
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << EOSSH
            set -e
            
            echo "üîµ DEVELOPMENT DEPLOYMENT STARTING"
            echo "=================================="
            
            # Set secrets as environment variables (already masked by GitHub Actions)
            export NEO4J_PASSWORD='${{ secrets.NEO4J_PASSWORD }}'
            export TELEGRAM_BOT_TOKEN='${{ secrets.TELEGRAM_BOT_TOKEN }}'
            export TELEGRAM_CHAT_ID='${{ secrets.TELEGRAM_CHAT_ID }}'
            
            # Verify password was set
            if [ -z "\${NEO4J_PASSWORD}" ]; then
              echo "‚ùå ERROR: NEO4J_PASSWORD is empty!"
              exit 1
            fi
            
            echo "‚úÖ NEO4J_PASSWORD successfully set (length: \${#NEO4J_PASSWORD} characters)"
            
            # Check Telegram configuration
            if [ -n "\${TELEGRAM_BOT_TOKEN}" ] && [ -n "\${TELEGRAM_CHAT_ID}" ]; then
              echo "‚úÖ Telegram alerting configured"
            else
              echo "‚ö†Ô∏è  Telegram alerting not configured (optional)"
            fi
            
            export ENVIRONMENT=dev
            
            # Navigate to veris-memory repository
            cd /opt/veris-memory
            
            # Pull latest changes (force to avoid lock issues)
            echo "üì• Pulling latest changes from repository..."
            git fetch origin --prune || git remote prune origin
            git reset --hard origin/main || (git fetch origin main && git reset --hard FETCH_HEAD)
            
            # No need to navigate to context-store - everything is in repo root
            # cd context-store
            
            # BACKUP PHASE - Preserve data before cleanup
            echo "üíæ BACKUP PHASE - Preserving Veris Memory data"
            echo "======================================"
            
            # Run backup script if it exists
            if [ -f "scripts/backup-restore-integration.sh" ]; then
              echo "üì¶ Running backup script..."
              chmod +x scripts/backup-restore-integration.sh
              ./scripts/backup-restore-integration.sh backup dev || {
                echo "‚ö†Ô∏è  Backup failed, but continuing with deployment"
              }
            else
              echo "‚ö†Ô∏è  Backup script not found, skipping backup"
            fi
            
            # BULLETPROOF CONTAINER CLEANUP - Run this BEFORE any deployment script
            echo "üõ°Ô∏è  BULLETPROOF CONTAINER CLEANUP"
            echo "======================================"
            
            # Method 1: Nuclear option - remove ALL veris-memory-dev containers
            echo "üóëÔ∏è  Method 1: Nuclear container removal..."
            docker ps -aq --filter "name=veris-memory-dev" | xargs -r docker rm -f 2>/dev/null || true
            
            # Method 2: Remove by exact container names
            echo "üóëÔ∏è  Method 2: Removing specific containers..."
            for container in veris-memory-dev-context-store-1 veris-memory-dev-qdrant-1 veris-memory-dev-neo4j-1 veris-memory-dev-redis-1; do
              docker rm -f "$container" 2>/dev/null || true
              echo "    ‚Üí Removed $container (if it existed)"
            done
            
            # Method 3: Kill any processes on our target ports
            echo "üóëÔ∏è  Method 3: Freeing target ports..."
            for port in 8000 6333 7474 7687 6379; do
              # Find and kill any processes using these ports
              pids=$(lsof -ti:$port 2>/dev/null || true)
              if [ -n "$pids" ]; then
                echo "    ‚Üí Killing processes on port $port: $pids"
                kill -9 $pids 2>/dev/null || true
              fi
              
              # Remove containers using these ports
              containers=$(docker ps -a --filter "publish=$port" --format "{{.Names}}" 2>/dev/null || true)
              if [ -n "$containers" ]; then
                echo "    ‚Üí Removing containers on port $port: $containers"
                echo "$containers" | xargs -r docker rm -f 2>/dev/null || true
              fi
            done
            
            # Method 4: Remove ALL volumes with veris-memory-dev prefix
            echo "üóëÔ∏è  Method 4: Nuclear volume removal..."
            docker volume ls -q --filter "name=veris-memory-dev" | xargs -r docker volume rm 2>/dev/null || true
            
            # CRITICAL: Also remove veris-memory (non-dev) Neo4j volumes to ensure password reset
            echo "üóëÔ∏è  Method 4b: Removing Neo4j volumes to ensure clean password state..."
            docker volume rm veris-memory_neo4j_data 2>/dev/null || true
            docker volume rm veris-memory_neo4j_logs 2>/dev/null || true
            echo "    ‚Üí Neo4j volumes removed (password will be reset)"
            
            # Method 5: Clean up networks
            echo "üóëÔ∏è  Method 5: Network cleanup..."
            docker network ls --filter "name=veris-memory-dev" --format "{{.Name}}" | xargs -r docker network rm 2>/dev/null || true
            
            # Method 6: Docker system cleanup (be conservative)
            echo "üóëÔ∏è  Method 6: System cleanup of unused resources..."
            docker system prune -f --volumes 2>/dev/null || true
            
            # Method 7: Wait a moment for Docker to settle
            echo "‚è≥ Waiting 3 seconds for Docker to settle..."
            sleep 3
            
            # Verification
            echo "‚úÖ Cleanup verification:"
            remaining_containers=$(docker ps -aq --filter "name=veris-memory-dev" | wc -l)
            remaining_volumes=$(docker volume ls -q --filter "name=veris-memory-dev" | wc -l)
            echo "    ‚Üí Remaining containers: $remaining_containers"
            echo "    ‚Üí Remaining volumes: $remaining_volumes"
            
            # Show what Docker sees now
            echo "üê≥ Current Docker state:"
            echo "    ‚Üí Running containers: $(docker ps --format '{{.Names}}' | wc -l)"
            echo "    ‚Üí All containers: $(docker ps -a --format '{{.Names}}' | wc -l)"
            echo "    ‚Üí Volumes: $(docker volume ls --format '{{.Name}}' | wc -l)"
            
            if [ "$remaining_containers" -eq 0 ] && [ "$remaining_volumes" -eq 0 ]; then
              echo "üéâ Complete cleanup achieved!"
            else
              echo "‚ö†Ô∏è  Some resources may still exist, but deployment will continue"
              docker ps -a --filter "name=veris-memory-dev" --format "table {{.Names}}\t{{.Status}}" || true
            fi
            
            # Check if deployment script exists
            if [ -f "scripts/deploy-environment.sh" ]; then
              echo "üöÄ Running environment deployment script for DEV..."
              chmod +x scripts/deploy-environment.sh
              ./scripts/deploy-environment.sh dev
            else
              echo "‚ö†Ô∏è Environment deployment script not found, using fallback..."
              
              # Fallback deployment for dev
              echo "üõë Stopping existing dev containers..."
              docker compose -p veris-memory-dev down --remove-orphans 2>/dev/null || true
              
              # Stop containers on dev ports (standard ports we test with)
              for port in 8000 6333 7474 7687 6379 6334; do
                containers=$(docker ps --filter "publish=$port" --format "{{.Names}}" 2>/dev/null || true)
                if [ -n "$containers" ]; then
                  echo "Stopping containers on port $port: $containers"
                  docker stop $containers 2>/dev/null || true
                  docker rm $containers 2>/dev/null || true
                fi
              done
              
              # Dev uses standard docker compose file
              COMPOSE_FILE="docker-compose.yml"
              echo "‚úÖ Using standard docker compose for dev environment"
              
              # Setup dev environment file
              if [ -f ".env.dev" ]; then
                cp .env.dev .env
              elif [ -f ".env.template" ]; then
                cp .env.template .env
              fi
              
              # Configure environment variables
              
              # Remove ALL NEO4J and TELEGRAM lines to ensure clean state
              echo "üóëÔ∏è  Removing ALL existing NEO4J and TELEGRAM lines from .env..."
              if [ -f .env ]; then
                grep -v "^NEO4J" .env > .env.tmp || true
                grep -v "^TELEGRAM" .env.tmp > .env || true
                rm -f .env.tmp
              fi
              
              # Write secrets to .env without echoing them
              {
                printf "NEO4J_PASSWORD=%s\n" "${{ secrets.NEO4J_PASSWORD }}"
                printf "NEO4J_AUTH=neo4j/%s\n" "${{ secrets.NEO4J_PASSWORD }}"

                # Add Telegram configuration if available
                if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then
                  printf "TELEGRAM_BOT_TOKEN=%s\n" "${{ secrets.TELEGRAM_BOT_TOKEN }}"
                fi
                if [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
                  printf "TELEGRAM_CHAT_ID=%s\n" "${{ secrets.TELEGRAM_CHAT_ID }}"
                fi

                # PR #170: Cache and Embedding Configuration
                printf "\n# Veris Memory Cache Configuration (PR #170)\n"
                printf "VERIS_CACHE_TTL_SECONDS=300\n"
                printf "STRICT_EMBEDDINGS=false\n"
                printf "EMBEDDING_DIM=384\n"
              } >> .env 2>/dev/null
              
              # Verify configuration was written correctly
              if ! grep -q "^NEO4J_PASSWORD=" .env; then
                echo "‚ùå ERROR: NEO4J_PASSWORD not found in .env!"
                exit 1
              fi
              
              # Verify password was set (without exposing it)
              if ! grep -q "^NEO4J_PASSWORD=.\+" .env; then
                echo "‚ùå ERROR: NEO4J_PASSWORD is not configured!"
                echo "‚ùå Check GitHub Secrets configuration"
                exit 1
              fi
              
              # Verify Telegram configuration if provided
              if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then
                if ! grep -q "^TELEGRAM_BOT_TOKEN=" .env; then
                  echo "‚ö†Ô∏è  WARNING: TELEGRAM_BOT_TOKEN was not written to .env"
                fi
              fi
              if [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
                if ! grep -q "^TELEGRAM_CHAT_ID=" .env; then
                  echo "‚ö†Ô∏è  WARNING: TELEGRAM_CHAT_ID was not written to .env"
                fi
              fi
              
              echo "‚úÖ Environment configuration completed"
              
              # Containers and volumes already cleaned up by bulletproof cleanup above
              echo "‚úÖ Using clean state from bulletproof cleanup"
              
              # Start dev services (secrets already exported at beginning)
              echo "üöÄ Starting DEV services..."
              
              # CRITICAL FIX: Force COMPLETE rebuild of API container
              echo "üö® FORCING COMPLETE API REBUILD (NO CACHE)"
              echo "==========================================="
              
              # Step 1: Stop and remove API container
              docker stop veris-memory-dev-api-1 2>/dev/null || true
              docker rm -f veris-memory-dev-api-1 2>/dev/null || true
              
              # Step 2: Remove ALL API-related images
              echo "Removing ALL cached API images..."
              docker rmi veris-memory-dev-api 2>/dev/null || true
              docker rmi veris-memory-dev_api 2>/dev/null || true
              docker images | grep -E "api|API" | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
              
              # Step 3: Prune build cache to ensure fresh build
              echo "Pruning Docker build cache..."
              docker builder prune -f 2>/dev/null || true
              docker system prune -f 2>/dev/null || true
              
              echo "‚úÖ All API caches cleared"
              
              # Build API separately with --no-cache FIRST
              echo "Building API from scratch (no cache)..."
              # Add timestamp as build arg to force cache invalidation
              docker compose -p veris-memory-dev -f "$COMPOSE_FILE" build --no-cache --build-arg CACHE_BUST=$(date +%s) api || {
                echo "‚ùå API build failed!"
                exit 1
              }
              
              # Try multiple approaches to ensure success
              echo "  ‚Üí Starting all services..."
              if ! docker compose -p veris-memory-dev -f "$COMPOSE_FILE" up -d; then
                echo "  ‚Üí Attempt 1 failed, trying without cache..."
                if ! docker compose -p veris-memory-dev -f "$COMPOSE_FILE" up -d --build --no-cache; then
                  echo "  ‚Üí Attempt 2 failed, trying with force recreate..."
                  if ! docker compose -p veris-memory-dev -f "$COMPOSE_FILE" up -d --build --force-recreate; then
                    echo "‚ùå All docker compose attempts failed!"
                    
                    # ENHANCED: Capture API container debugging info
                    echo ""
                    echo "üîç DEBUGGING API CONTAINER FAILURE:"
                    echo "===================================="
                    API_CONTAINER="veris-memory-dev-api-1"
                    
                    echo "üìä Container Status:"
                    docker ps -a --filter "name=$API_CONTAINER" || true
                    
                    echo ""
                    echo "üìú API Container Logs (last 100 lines):"
                    docker logs "$API_CONTAINER" --tail 100 2>&1 || echo "No logs available"
                    
                    echo ""
                    echo "üîç Container Exit Details:"
                    docker inspect "$API_CONTAINER" --format 'Exit Code: {{.State.ExitCode}}, Error: {{.State.Error}}' 2>/dev/null || true
                    
                    echo ""
                    echo "üìÅ Check startup script in container:"
                    docker run --rm --entrypoint sh veris-memory-dev-api:latest -c "ls -la /app/api-startup.sh 2>/dev/null || echo 'Script not found'" || true
                    
                    exit 1
                  fi
                fi
              fi
              
              echo "‚úÖ Docker compose completed successfully"
              
              # ENHANCED: Immediately check API container status
              echo ""
              echo "üîç Checking API container status immediately..."
              sleep 5  # Give container 5 seconds to start
              API_CONTAINER="veris-memory-dev-api-1"
              API_STATUS=$(docker inspect "$API_CONTAINER" --format '{{.State.Status}}' 2>/dev/null || echo "not-found")
              API_EXIT=$(docker inspect "$API_CONTAINER" --format '{{.State.ExitCode}}' 2>/dev/null || echo "N/A")
              
              if [ "$API_STATUS" != "running" ]; then
                echo "‚ö†Ô∏è  WARNING: API container is not running!"
                echo "  Status: $API_STATUS"
                echo "  Exit Code: $API_EXIT"
                echo ""
                echo "üìú API Container Logs:"
                docker logs "$API_CONTAINER" 2>&1 || echo "No logs"
                echo ""
                echo "üîç Debugging info:"
                docker inspect "$API_CONTAINER" --format 'Status: {{.State.Status}}, Exit Code: {{.State.ExitCode}}, Error: {{.State.Error}}, Started: {{.State.StartedAt}}, Finished: {{.State.FinishedAt}}, Command: {{join .Config.Cmd " "}}' 2>/dev/null || true
                echo ""
                echo "üìÅ Files in container:"
                docker run --rm --entrypoint ls veris-memory-dev-api:latest -la /app/ 2>&1 | head -20 || true
              else
                echo "‚úÖ API container is running"
              fi
              
              # Verify .env integrity after deployment
              if ! grep -q "^NEO4J_PASSWORD=" .env; then
                echo "‚ùå ERROR: NEO4J_PASSWORD was removed during deployment!"
                exit 1
              fi
              
              # Fix Neo4j password synchronization
              echo "üîê Ensuring Neo4j password is synchronized..."
              if [ -f "scripts/neo4j-password-fix.sh" ]; then
                chmod +x scripts/neo4j-password-fix.sh
                export CI=true  # Run in CI mode for auto-confirmation
                ./scripts/neo4j-password-fix.sh || {
                  echo "‚ö†Ô∏è  Neo4j password sync failed, but continuing..."
                }
              else
                echo "‚ö†Ô∏è  Neo4j password fix script not found"
              fi
              
              echo "‚úÖ Password configuration completed"
              
              # Configure Telegram alerting
              echo "üì± Configuring Telegram alerting..."
              if [ -f "scripts/telegram-setup.sh" ]; then
                chmod +x scripts/telegram-setup.sh
                export CI=true  # Run in CI mode for auto-confirmation
                # Export secrets for the script to use
                export TELEGRAM_BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
                export TELEGRAM_CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
                ./scripts/telegram-setup.sh || {
                  echo "‚ö†Ô∏è  Telegram setup completed (may be skipped if not configured)"
                }
              else
                echo "‚ö†Ô∏è  Telegram setup script not found"
              fi
              
              echo "üîç ============================================"
              
              # RESTORE PHASE - Recover data after deployment
              echo "üì• RESTORE PHASE - Recovering Veris Memory data"
              echo "======================================"
              
              # Wait a bit for containers to stabilize
              sleep 10
              
              # Run restore script if it exists
              if [ -f "scripts/backup-restore-integration.sh" ]; then
                echo "üì¶ Running restore script..."
                chmod +x scripts/backup-restore-integration.sh
                ./scripts/backup-restore-integration.sh restore dev || {
                  echo "‚ö†Ô∏è  Restore failed, data may need manual recovery"
                }
              else
                echo "‚ö†Ô∏è  Restore script not found, skipping restore"
              fi
              
              # Bootstrap Qdrant if needed (only if restore didn't work)
              echo "üîß Bootstrapping Qdrant collection..."
              sleep 5  # Give services time after restore
              python3 ops/bootstrap/qdrant_bootstrap.py --qdrant-url http://localhost:6333 --ensure-collection || echo "Bootstrap completed or not needed"
              
              # Wait for services with better error reporting
              echo "‚è≥ Waiting for DEV services to be healthy..."
              
              # Check health status of containers and report issues
              echo "üîç Checking container health status..."
              docker ps --format "table {{.Names}}\t{{.Status}}" | grep veris-memory-dev || true
              
              # Check for unhealthy containers and show detailed health check errors
              unhealthy=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" | grep veris-memory-dev || true)
              exited=$(docker ps -a --filter "status=exited" --format "{{.Names}}" | grep veris-memory-dev || true)
              
              # ENHANCED: Check for exited containers (Error status)
              if [ -n "$exited" ]; then
                echo "‚ùå ============================================"
                echo "‚ùå CRITICAL: CONTAINERS EXITED WITH ERROR!"
                echo "‚ùå ============================================"
                for container in $exited; do
                  echo "‚ùå Container: $container"
                  EXIT_CODE=$(docker inspect $container --format='{{.State.ExitCode}}')
                  echo "   Exit Code: $EXIT_CODE"
                  echo "   Last 50 log lines:"
                  docker logs $container --tail 50 2>&1
                  echo ""
                done
                echo "‚ùå ============================================"
              fi
              
              if [ -n "$unhealthy" ]; then
                echo "‚ö†Ô∏è  ============================================"
                echo "‚ö†Ô∏è  WARNING: UNHEALTHY CONTAINERS DETECTED!"
                echo "‚ö†Ô∏è  ============================================"
                for container in $unhealthy; do
                  echo "‚ùå Container: $container"
                  echo "   Health check errors:"
                  docker inspect $container --format='{{range .State.Health.Log}}{{.Output}}{{end}}' | head -3
                  echo ""
                done
                echo "‚ö†Ô∏è  ============================================"
              fi
              
              timeout=300
              count=0
              # Dev always uses standard ports (8000)
              health_url="http://localhost:8000/health"
              
              while [ $count -lt $timeout ]; do
                if curl -f "$health_url" > /dev/null 2>&1; then
                  echo "‚úÖ DEV services are healthy"
                  break
                fi
                echo "Waiting... ($count/$timeout)"
                sleep 10
                count=$((count + 10))
              done
              
              if [ $count -ge $timeout ]; then
                echo "‚ùå DEV services failed to become healthy"
                docker compose -p veris-memory-dev -f "$COMPOSE_FILE" logs --tail=50
                exit 1
              fi
            fi
            
            # Configure Neo4j Performance Index (PR #170)
            echo ""
            echo "üîß Creating Neo4j performance index..."
            echo "=================================="

            # Wait a bit longer for Neo4j to be fully ready for index creation
            sleep 10

            # Use the NEO4J_PASSWORD environment variable that was exported earlier
            if [ -z "$NEO4J_PASSWORD" ]; then
              echo "‚ö†Ô∏è  NEO4J_PASSWORD not set in environment, skipping index creation"
            else
              # Create context_id_index for 2-5x faster relationship validation
              echo "Creating context_id_index for relationship performance..."
              docker exec veris-memory-dev-neo4j-1 cypher-shell \
                -u neo4j \
                -p "$NEO4J_PASSWORD" \
                -d neo4j \
                "CREATE INDEX context_id_index IF NOT EXISTS FOR (n:Context) ON (n.id);" 2>&1 | grep -v "password" || {
                echo "‚ö†Ô∏è  Index creation failed, may already exist or Neo4j not ready"
                echo "   This is non-critical, system will work but relationship validation will be slower"
              }

              # Verify index was created
              echo "Verifying index status..."
              docker exec veris-memory-dev-neo4j-1 cypher-shell \
                -u neo4j \
                -p "$NEO4J_PASSWORD" \
                -d neo4j \
                "SHOW INDEXES;" 2>&1 | grep -E "context_id_index|name.*type.*state" | head -5 || true

              echo "‚úÖ Neo4j index configuration completed"
            fi

            # Configure firewall for exposed services
            echo ""
            echo "üî• Configuring firewall rules..."
            echo "=================================="

            # Run comprehensive firewall setup script
            echo "Running firewall setup script..."
            chmod +x scripts/setup-firewall.sh
            sudo ./scripts/setup-firewall.sh

            echo "‚úÖ Firewall configuration completed"

            echo ""
            echo "üîµ DEV DEPLOYMENT COMPLETED"
            echo "=================================="
          EOSSH

      - name: Verify Dev Deployment
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üîç Verifying DEV deployment..."
            cd /opt/veris-memory
            
            # Show dev containers
            echo "Dev containers running:"
            docker ps --format "table {{.Names}}\t{{.Status}}" | grep -E "dev|NAME" || docker ps --format "table {{.Names}}\t{{.Status}}" | head -5
            
            # Check dev service health
            echo ""
            echo "Dev service health:"
            
            # Dev uses standard ports (what we test with)
            echo -n "  Redis: "
            echo "PING" | nc -w 2 localhost 6379 | grep -q PONG && echo "‚úì (6379)" || echo "‚úó"
            
            echo -n "  Neo4j: "
            timeout 1 bash -c "</dev/tcp/localhost/7474" 2>/dev/null && echo "‚úì (7474)" || echo "‚úó"
            
            echo -n "  Qdrant: "
            curl -s http://localhost:6333/health > /dev/null 2>&1 && echo "‚úì (6333)" || echo "‚úó"
            
            echo -n "  MCP Server: "
            curl -s http://localhost:8000/health > /dev/null 2>&1 && echo "‚úì (8000)" || echo "‚úó"
            
            echo -n "  REST API: "
            curl -s http://localhost:8001/api/v1/health > /dev/null 2>&1 && echo "‚úì (8001)" || echo "‚úó"
          EOF

      - name: Generate Deployment Report
        id: deployment-report
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üìä Generating deployment report..."
            cd /opt/veris-memory
            
            # Create deployment report script if it doesn't exist
            if [ ! -f "scripts/deployment-report.sh" ]; then
              echo "‚ö†Ô∏è Deployment report script not found, creating basic report..."
              
              # Create a basic report
              cat > /tmp/deployment-report.json << REPORT
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "environment": "dev",
            "server": "$(hostname)",
            "containers": {
              "running": $(docker ps --filter "name=veris-memory-dev" --format "{{.Names}}" | wc -l),
              "list": $(docker ps --filter "name=veris-memory-dev" --format "{{json .Names}}" | jq -s .)
            },
            "services": {
              "api": $(curl -sf http://localhost:8000/health > /dev/null 2>&1 && echo '"healthy"' || echo '"unhealthy"'),
              "qdrant": $(curl -sf http://localhost:6333/ > /dev/null 2>&1 && echo '"healthy"' || echo '"unhealthy"'),
              "neo4j": $(timeout 2 bash -c "</dev/tcp/localhost/7687" 2>/dev/null && echo '"healthy"' || echo '"unhealthy"'),
              "redis": $(echo "PING" | nc -w 2 localhost 6379 | grep -q PONG && echo '"healthy"' || echo '"unhealthy"')
            },
            "success": true
          }
          REPORT
              cat /tmp/deployment-report.json
            else
              # Run the full deployment report
              chmod +x scripts/deployment-report.sh
              ./scripts/deployment-report.sh dev
              
              # Output the latest report
              if [ -f "/tmp/deployment-report-dev.json" ]; then
                cat /tmp/deployment-report-dev.json
              fi
            fi
            
            # Save report for artifact upload
            mkdir -p /opt/veris-memory/deployment-reports
            cp /tmp/deployment-report*.json /opt/veris-memory/deployment-reports/ 2>/dev/null || true
          EOF
          
      - name: Run Dev Smoke Tests
        continue-on-error: true
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üß™ Running smoke tests on DEV environment..."
            cd /opt/veris-memory
            
            # Dev uses standard ports (dual-service architecture)
            MCP_URL="http://localhost:8000"
            API_URL="http://localhost:8001"
            QDRANT_URL="http://localhost:6333"
            NEO4J_URL="http://localhost:7474"
            echo "Testing dev environment with dual-service architecture..."
            echo "  MCP Server: $MCP_URL"
            echo "  REST API: $API_URL"
            
            # Run smoke tests if available
            if [ -f "ops/smoke/smoke_runner.py" ]; then
              python3 ops/smoke/smoke_runner.py \
                --api-url "$API_URL" \
                --qdrant-url "$QDRANT_URL" \
                --neo4j-url "$NEO4J_URL" \
                --timeout 30 || echo "‚ö†Ô∏è Some smoke tests failed (non-blocking)"
            else
              echo "‚ö†Ô∏è Smoke test runner not found, skipping tests"
            fi
          EOF

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_ed25519

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Development deployment successful!"
            echo "üîµ Environment: DEV"
            echo "üåê Server: ${{ secrets.HETZNER_HOST }}"
            echo "üìç Location: /opt/veris-memory"
            echo ""
            echo "üìù Note: Production deployment requires manual intervention"
          else
            echo "‚ùå Development deployment failed!"
            echo "Please check the logs for details"
          fi