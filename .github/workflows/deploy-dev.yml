name: Deploy to Development Environment

on:
  push:
    branches: [main]
    paths:
      - 'context-store/**'
      - '.github/workflows/deploy-dev.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

jobs:
  deploy-dev:
    name: Deploy to Dev Environment
    runs-on: ubuntu-latest
    environment: development
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          # Mask secrets in logs
          echo "::add-mask::${{ secrets.HETZNER_SSH_KEY }}"
          echo "::add-mask::${{ secrets.NEO4J_PASSWORD }}"
          
          # Create SSH key with secure permissions
          # Use printf to preserve newlines in the key
          printf '%s\n' "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          # Add SSH host to known hosts to avoid prompt
          ssh-keyscan -t ed25519 -H ${{ secrets.HETZNER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH key format
          if ! ssh-keygen -l -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "Error: Invalid SSH key format"
            exit 1
          fi

      - name: Deploy to Dev Environment
        run: |
          # SIMPLE PASSWORD HANDLING:
          # ========================
          # Store the password as PLAIN TEXT in GitHub Secrets
          # GitHub Secrets are already encrypted and secure
          # No need for base64 encoding - it just adds complexity
          
          # Verify the secret exists
          if [ -z '${{ secrets.NEO4J_PASSWORD }}' ]; then
            echo "‚ùå ERROR: NEO4J_PASSWORD secret is not set in GitHub Actions!"
            echo "Please set the NEO4J_PASSWORD secret in: Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi
          
          echo "‚úÖ NEO4J_PASSWORD secret exists in GitHub Actions"
          
          # Pass the password directly to the remote server
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << EOSSH
            set -e
            
            echo "üîµ DEVELOPMENT DEPLOYMENT STARTING"
            echo "=================================="
            
            # Set the password directly from GitHub Secrets
            export NEO4J_PASSWORD='${{ secrets.NEO4J_PASSWORD }}'
            
            # Verify password was set
            if [ -z "\${NEO4J_PASSWORD}" ]; then
              echo "‚ùå ERROR: NEO4J_PASSWORD is empty!"
              exit 1
            fi
            
            echo "‚úÖ NEO4J_PASSWORD successfully set (length: \${#NEO4J_PASSWORD} characters)"
            export ENVIRONMENT=dev
            
            # Navigate to veris-memory repository
            cd /opt/veris-memory
            
            # Pull latest changes (force to avoid lock issues)
            echo "üì• Pulling latest changes from repository..."
            git fetch origin --prune || git remote prune origin
            git reset --hard origin/main || (git fetch origin main && git reset --hard FETCH_HEAD)
            
            # No need to navigate to context-store - everything is in repo root
            # cd context-store
            
            # Check if deployment script exists
            if [ -f "scripts/deploy-environment.sh" ]; then
              echo "üöÄ Running environment deployment script for DEV..."
              chmod +x scripts/deploy-environment.sh
              ./scripts/deploy-environment.sh dev
            else
              echo "‚ö†Ô∏è Environment deployment script not found, using fallback..."
              
              # Fallback deployment for dev
              echo "üõë Stopping existing dev containers..."
              docker compose -p veris-memory-dev down --remove-orphans 2>/dev/null || true
              
              # Stop containers on dev ports (standard ports we test with)
              for port in 8000 6333 7474 7687 6379 6334; do
                containers=$(docker ps --filter "publish=$port" --format "{{.Names}}" 2>/dev/null || true)
                if [ -n "$containers" ]; then
                  echo "Stopping containers on port $port: $containers"
                  docker stop $containers 2>/dev/null || true
                  docker rm $containers 2>/dev/null || true
                fi
              done
              
              # Dev uses standard docker compose file
              COMPOSE_FILE="docker-compose.yml"
              echo "‚úÖ Using standard docker compose for dev environment"
              
              # Setup dev environment file
              if [ -f ".env.dev" ]; then
                cp .env.dev .env
              elif [ -f ".env.template" ]; then
                cp .env.template .env
              fi
              
              # CRITICAL: Debug and fix password issues
              echo "üîç ============================================"
              echo "üîç DEBUG: Password Configuration"
              echo "üîç ============================================"
              
              # Show what's currently in .env (if it exists)
              if [ -f .env ]; then
                echo "üìã Current .env NEO4J entries BEFORE modification:"
                grep NEO4J .env || echo "  No NEO4J entries found"
              fi
              
              # Remove ALL NEO4J lines (both PASSWORD and AUTH)
              echo "üóëÔ∏è  Removing ALL existing NEO4J lines from .env..."
              if [ -f .env ]; then
                grep -v "^NEO4J" .env > .env.tmp || true
                mv .env.tmp .env
              fi
              
              # Write the correct password from GitHub Secrets
              export NEO4J_PASSWORD='${{ secrets.NEO4J_PASSWORD }}'
              echo "‚úèÔ∏è  Writing NEO4J_PASSWORD from GitHub Secrets..."
              echo "NEO4J_PASSWORD=${{ secrets.NEO4J_PASSWORD }}" >> .env
              echo "NEO4J_AUTH=neo4j/${{ secrets.NEO4J_PASSWORD }}" >> .env
              
              # Verify what we wrote
              echo "üìã NEW .env NEO4J entries AFTER modification:"
              grep NEO4J .env || echo "  ERROR: No NEO4J entries found!"
              
              # Check password length to verify it's not empty (without exposing it)
              PASSWORD_LENGTH=$(grep "^NEO4J_PASSWORD=" .env | cut -d= -f2 | wc -c)
              echo "üîê Password length: $PASSWORD_LENGTH characters"
              
              if [ "$PASSWORD_LENGTH" -lt 5 ]; then
                echo "‚ùå ============================================"
                echo "‚ùå FATAL ERROR: NEO4J_PASSWORD is too short or empty!"
                echo "‚ùå Password must be at least 5 characters"
                echo "‚ùå Check GitHub Secrets configuration"
                echo "‚ùå ============================================"
                exit 1
              fi
              
              # Also verify Neo4j container can use this password
              echo "üîç Neo4j will be configured with:"
              echo "  - Username: neo4j"
              echo "  - Password length: $PASSWORD_LENGTH characters"
              echo "  - Password starts with: $(grep "^NEO4J_PASSWORD=" .env | cut -d= -f2 | cut -c1-3)***"
              
              echo "‚úÖ Password configuration completed"
              echo "üîç ============================================"
              
              # Stop any existing containers first (force remove)
              echo "üõë Stopping any existing DEV services..."
              docker compose -p veris-memory-dev -f "$COMPOSE_FILE" down -v --remove-orphans || true
              # Extra cleanup in case containers are stuck
              docker ps -a | grep veris-memory-dev | awk '{print $1}' | xargs -r docker rm -f || true
              
              # CRITICAL: Remove Neo4j volumes to ensure password reset
              echo "üóëÔ∏è  Removing Neo4j volumes to ensure clean authentication..."
              docker volume ls | grep veris-memory-dev | grep neo4j | awk '{print $2}' | xargs -r docker volume rm || true
              # Also try with explicit volume names
              docker volume rm veris-memory-dev_neo4j_data veris-memory-dev_neo4j_logs 2>/dev/null || true
              
              echo "‚úÖ Neo4j volumes removed - will use fresh password on startup"
              
              # Start dev services with NEO4J_PASSWORD exported for health checks
              echo "üöÄ Starting DEV services..."
              export NEO4J_PASSWORD='${{ secrets.NEO4J_PASSWORD }}'
              docker compose -p veris-memory-dev -f "$COMPOSE_FILE" up -d --build
              
              # CRITICAL: Verify .env wasn't changed by docker-compose or any script
              echo "üîç ============================================"
              echo "üîç POST-DEPLOY: Verifying .env integrity"
              echo "üîç ============================================"
              echo "üìã .env NEO4J entries AFTER docker-compose:"
              grep NEO4J .env || echo "  ERROR: No NEO4J entries found!"
              
              # Check if password matches what we expect
              ACTUAL_PASSWORD=$(grep "^NEO4J_PASSWORD=" .env | cut -d= -f2)
              EXPECTED_START=$(echo "${{ secrets.NEO4J_PASSWORD }}" | cut -c1-3)
              ACTUAL_START=$(echo "$ACTUAL_PASSWORD" | cut -c1-3)
              
              if [ "$ACTUAL_START" != "$EXPECTED_START" ]; then
                echo "‚ùå ============================================"
                echo "‚ùå FATAL: Password was changed after deployment!"
                echo "‚ùå Expected to start with: $EXPECTED_START***"
                echo "‚ùå Actually starts with: $ACTUAL_START***"
                echo "‚ùå Something is overwriting the .env file!"
                echo "‚ùå ============================================"
                exit 1
              fi
              echo "‚úÖ Password verification passed"
              echo "üîç ============================================"
              
              # Bootstrap Qdrant if needed
              echo "üîß Bootstrapping Qdrant collection..."
              sleep 10  # Give Qdrant time to fully start
              python3 ops/bootstrap/qdrant_bootstrap.py --qdrant-url http://localhost:6333 --ensure-collection || echo "Bootstrap completed or not needed"
              
              # Wait for services with better error reporting
              echo "‚è≥ Waiting for DEV services to be healthy..."
              
              # Check health status of containers and report issues
              echo "üîç Checking container health status..."
              docker ps --format "table {{.Names}}\t{{.Status}}" | grep veris-memory-dev || true
              
              # Check for unhealthy containers and show detailed health check errors
              unhealthy=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" | grep veris-memory-dev || true)
              if [ -n "$unhealthy" ]; then
                echo "‚ö†Ô∏è  ============================================"
                echo "‚ö†Ô∏è  WARNING: UNHEALTHY CONTAINERS DETECTED!"
                echo "‚ö†Ô∏è  ============================================"
                for container in $unhealthy; do
                  echo "‚ùå Container: $container"
                  echo "   Health check errors:"
                  docker inspect $container --format='{{range .State.Health.Log}}{{.Output}}{{end}}' | head -3
                  echo ""
                done
                echo "‚ö†Ô∏è  ============================================"
              fi
              
              timeout=300
              count=0
              # Dev always uses standard ports (8000)
              health_url="http://localhost:8000/health"
              
              while [ $count -lt $timeout ]; do
                if curl -f "$health_url" > /dev/null 2>&1; then
                  echo "‚úÖ DEV services are healthy"
                  break
                fi
                echo "Waiting... ($count/$timeout)"
                sleep 10
                count=$((count + 10))
              done
              
              if [ $count -ge $timeout ]; then
                echo "‚ùå DEV services failed to become healthy"
                docker compose -p veris-memory-dev -f "$COMPOSE_FILE" logs --tail=50
                exit 1
              fi
            fi
            
            echo ""
            echo "üîµ DEV DEPLOYMENT COMPLETED"
            echo "=================================="
          EOSSH

      - name: Verify Dev Deployment
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üîç Verifying DEV deployment..."
            cd /opt/veris-memory/context-store
            
            # Show dev containers
            echo "Dev containers running:"
            docker ps --format "table {{.Names}}\t{{.Status}}" | grep -E "dev|NAME" || docker ps --format "table {{.Names}}\t{{.Status}}" | head -5
            
            # Check dev service health
            echo ""
            echo "Dev service health:"
            
            # Dev uses standard ports (what we test with)
            echo -n "  Redis: "
            echo "PING" | nc -w 2 localhost 6379 | grep -q PONG && echo "‚úì (6379)" || echo "‚úó"
            
            echo -n "  Neo4j: "
            timeout 1 bash -c "</dev/tcp/localhost/7474" 2>/dev/null && echo "‚úì (7474)" || echo "‚úó"
            
            echo -n "  Qdrant: "
            curl -s http://localhost:6333/health > /dev/null 2>&1 && echo "‚úì (6333)" || echo "‚úó"
            
            echo -n "  API: "
            curl -s http://localhost:8000/health > /dev/null 2>&1 && echo "‚úì (8000)" || echo "‚úó"
          EOF

      - name: Run Dev Smoke Tests
        continue-on-error: true
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üß™ Running smoke tests on DEV environment..."
            cd /opt/veris-memory
            
            # Dev uses standard ports (what we test with)
            API_URL="http://localhost:8000"
            QDRANT_URL="http://localhost:6333"
            NEO4J_URL="http://localhost:7474"
            echo "Testing dev environment on standard ports..."
            
            # Run smoke tests if available
            if [ -f "ops/smoke/smoke_runner.py" ]; then
              python3 ops/smoke/smoke_runner.py \
                --api-url "$API_URL" \
                --qdrant-url "$QDRANT_URL" \
                --neo4j-url "$NEO4J_URL" \
                --timeout 30 || echo "‚ö†Ô∏è Some smoke tests failed (non-blocking)"
            else
              echo "‚ö†Ô∏è Smoke test runner not found, skipping tests"
            fi
          EOF

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_ed25519

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Development deployment successful!"
            echo "üîµ Environment: DEV"
            echo "üåê Server: ${{ secrets.HETZNER_HOST }}"
            echo "üìç Location: /opt/veris-memory"
            echo ""
            echo "üìù Note: Production deployment requires manual intervention"
          else
            echo "‚ùå Development deployment failed!"
            echo "Please check the logs for details"
          fi