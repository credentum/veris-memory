name: Deploy to Development Environment

on:
  # Deploy immediately on push to main (runs in parallel with CVE scan)
  # Deployment script has smart fallback: tries GHCR, falls back to local build if not ready
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'schemas/**'
      - 'contracts/**'
      - 'voice-bot/**'
      - 'requirements.txt'
      - 'dockerfiles/Dockerfile*'
      - 'docker-compose*.yml'
      - '.env*'
      - 'scripts/deploy-dev.sh'
      - 'scripts/deploy-environment.sh'
      - 'scripts/init-neo4j-schema.sh'
      - 'deployments/**'
      - '.github/workflows/deploy-dev.yml'

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

jobs:
  deploy-dev:
    name: Deploy to Dev Environment
    runs-on: ubuntu-latest
    environment: development

    steps:

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          # Mask secrets in logs
          echo "::add-mask::${{ secrets.HETZNER_SSH_KEY }}"
          echo "::add-mask::${{ secrets.NEO4J_PASSWORD }}"
          echo "::add-mask::${{ secrets.NEO4J_RO_PASSWORD }}"
          echo "::add-mask::${{ secrets.REDIS_PASSWORD }}"
          echo "::add-mask::${{ secrets.TELEGRAM_BOT_TOKEN }}"
          echo "::add-mask::${{ secrets.TELEGRAM_CHAT_ID }}"
          echo "::add-mask::${{ secrets.API_KEY_MCP }}"
          echo "::add-mask::${{ secrets.LIVEKIT_API_KEY }}"
          echo "::add-mask::${{ secrets.LIVEKIT_API_SECRET }}"
          echo "::add-mask::${{ secrets.API_KEY_VOICEBOT }}"
          echo "::add-mask::${{ secrets.OPENAI_API_KEY }}"
          echo "::add-mask::${{ secrets.SENTINEL_API_KEY }}"
          echo "::add-mask::${{ secrets.HOST_CHECK_SECRET }}"

          # Create SSH key with secure permissions
          # Use printf to preserve newlines in the key
          printf '%s\n' "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

          # Add SSH host to known hosts to avoid prompt
          ssh-keyscan -t ed25519 -H ${{ secrets.HETZNER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

          # Test SSH key format
          if ! ssh-keygen -l -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "Error: Invalid SSH key format"
            exit 1
          fi

      - name: Determine deployment type
        id: deploy-type
        run: |
          # Check if any infrastructure files changed (requires full deploy)
          INFRA_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E "requirements\.txt|Dockerfile|docker-compose.*\.yml" || true)

          if [ -n "$INFRA_CHANGED" ] || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "type=full" >> $GITHUB_OUTPUT
            echo "üîÑ Infrastructure change detected - full deployment required"
          else
            echo "type=fast" >> $GITHUB_OUTPUT
            echo "‚ö° Code-only change - using fast deployment"
          fi

      - name: Fast Code Deployment (code changes only)
        id: fast-deploy
        if: steps.deploy-type.outputs.type == 'fast'
        continue-on-error: true
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 \
              ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOSSH'
            set -e
            echo "‚ö° FAST CODE-ONLY DEPLOYMENT"
            echo "=============================="
            cd /opt/veris-memory

            # Pull latest code
            echo "üì• Pulling latest code..."
            git fetch origin main
            git reset --hard origin/main
            COMMIT=$(git rev-parse --short HEAD)
            echo "‚úÖ Code updated to: $COMMIT"

            # Check if services are running
            PROJECT_NAME="veris-memory-dev"
            COMPOSE_FILE="docker-compose.deploy-dev.yml"

            # Verify .env file exists (created by full deployment)
            if [ ! -f .env ]; then
                echo "‚ùå ERROR: .env file not found - need full deployment first"
                exit 1
            fi
            echo "‚úÖ Found .env file"

            # Validate all required secrets are present in .env
            # If any are missing, exit with code 2 to trigger full deployment
            REQUIRED_SECRETS="NEO4J_PASSWORD REDIS_PASSWORD API_KEY_MCP SENTINEL_API_KEY"
            MISSING_SECRETS=""
            for SECRET in $REQUIRED_SECRETS; do
                if ! grep -q "^${SECRET}=" .env || [ -z "$(grep "^${SECRET}=" .env | cut -d= -f2-)" ]; then
                    MISSING_SECRETS="$MISSING_SECRETS $SECRET"
                fi
            done

            if [ -n "$MISSING_SECRETS" ]; then
                echo "‚ùå ERROR: Missing required secrets in .env:$MISSING_SECRETS"
                echo "‚ö†Ô∏è  Fast deployment cannot proceed - need full deployment to rebuild .env"
                exit 2
            fi
            echo "‚úÖ All required secrets present in .env"

            RUNNING=$(docker compose -p ${PROJECT_NAME} -f ${COMPOSE_FILE} --env-file .env ps --status running -q 2>/dev/null | wc -l)

            if [ "$RUNNING" -gt 0 ]; then
                echo "‚úÖ Found $RUNNING running services"

                # Recreate Python services to load new code
                # Using --force-recreate instead of restart because:
                # - restart only restarts process inside existing container
                # - git reset changes file inodes, but container caches old inodes
                # - force-recreate creates fresh containers with new volume bindings
                # Using --env-file .env to explicitly load environment variables
                echo "üîÑ Recreating Python services to load new code..."
                docker compose -p ${PROJECT_NAME} -f ${COMPOSE_FILE} --env-file .env up -d --force-recreate --no-build context-store api sentinel

                echo "‚è±Ô∏è  Waiting for services to be healthy..."
                sleep 20

                # Verify health
                if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
                    echo "‚úÖ MCP Server healthy"
                else
                    echo "‚ùå MCP Server not responding after recreate"
                    docker compose -p ${PROJECT_NAME} -f ${COMPOSE_FILE} logs context-store --tail=30
                    exit 1
                fi

                if curl -sf http://localhost:8001/api/v1/health > /dev/null 2>&1; then
                    echo "‚úÖ REST API healthy"
                else
                    echo "‚ö†Ô∏è  REST API not responding (non-blocking)"
                fi
            else
                echo "‚ö†Ô∏è  No services running - need full deployment"
                exit 1
            fi

            echo ""
            echo "‚úÖ FAST DEPLOYMENT COMPLETE - commit: $COMMIT"
          EOSSH

      - name: Log fallback reason
        if: steps.fast-deploy.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è Fast deployment failed - falling back to full deployment"
          echo "This usually means .env is missing required secrets"
          echo "Full deployment will rebuild .env with all secrets from GitHub"

      - name: Force cleanup stale containers
        if: steps.deploy-type.outputs.type == 'full' || steps.fast-deploy.outcome == 'failure'
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 \
              ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOSSH'
            echo "üßπ Force cleanup of stale containers before deployment..."

            # PR #384: Force remove all veris-memory containers by ID
            # This handles the "container name already in use" error
            STALE_CONTAINERS=$(docker ps -aq --filter "name=veris-memory" 2>/dev/null || true)
            if [ -n "$STALE_CONTAINERS" ]; then
              echo "   Found stale containers, force removing..."
              echo "$STALE_CONTAINERS" | xargs -r docker rm -f 2>/dev/null || true
            else
              echo "   No stale containers found"
            fi

            # Also clean up any orphaned networks
            docker network prune -f 2>/dev/null || true

            echo "‚úÖ Cleanup complete"
          EOSSH

      - name: Full Deployment (infrastructure changes or fast deploy failed)
        if: steps.deploy-type.outputs.type == 'full' || steps.fast-deploy.outcome == 'failure'
        env:
          NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD }}
          NEO4J_RO_PASSWORD: ${{ secrets.NEO4J_RO_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          API_KEY_MCP: ${{ secrets.API_KEY_MCP }}
          LIVEKIT_API_KEY: ${{ secrets.LIVEKIT_API_KEY }}
          LIVEKIT_API_SECRET: ${{ secrets.LIVEKIT_API_SECRET }}
          LIVEKIT_API_WEBSOCKET: ${{ secrets.LIVEKIT_API_WEBSOCKET }}
          API_KEY_VOICEBOT: ${{ secrets.API_KEY_VOICEBOT }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SENTINEL_API_KEY: ${{ secrets.SENTINEL_API_KEY }}
          HOST_CHECK_SECRET: ${{ secrets.HOST_CHECK_SECRET }}
          HETZNER_USER: ${{ secrets.HETZNER_USER }}
          HETZNER_HOST: ${{ secrets.HETZNER_HOST }}
          GITHUB_TOKEN: ${{ secrets.GHCR_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          chmod +x scripts/deploy-dev.sh
          ./scripts/deploy-dev.sh
      - name: Verify Dev Deployment
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üîç Verifying DEV deployment..."
            cd /opt/veris-memory
            
            # Show dev containers
            echo "Dev containers running:"
            docker ps --format "table {{.Names}}\t{{.Status}}" | grep -E "dev|NAME" || docker ps --format "table {{.Names}}\t{{.Status}}" | head -5
            
            # Check dev service health
            echo ""
            echo "Dev service health:"
            
            # Dev uses standard ports (what we test with)
            echo -n "  Redis: "
            docker inspect --format='{{.State.Health.Status}}' veris-memory-dev-redis-1 2>/dev/null | grep -q "healthy" && echo "‚úì (6379)" || echo "‚úó"
            
            echo -n "  Neo4j: "
            timeout 1 bash -c "</dev/tcp/localhost/7474" 2>/dev/null && echo "‚úì (7474)" || echo "‚úó"
            
            echo -n "  Qdrant: "
            curl -s http://localhost:6333/health > /dev/null 2>&1 && echo "‚úì (6333)" || echo "‚úó"
            
            echo -n "  MCP Server: "
            curl -s http://localhost:8000/health > /dev/null 2>&1 && echo "‚úì (8000)" || echo "‚úó"

            echo -n "  REST API: "
            curl -s http://localhost:8001/api/v1/health > /dev/null 2>&1 && echo "‚úì (8001)" || echo "‚úó"

            echo -n "  Voice-Bot: "
            curl -k -s https://localhost:8002/health > /dev/null 2>&1 && echo "‚úì HTTPS (8002)" || \
            curl -s http://localhost:8002/health > /dev/null 2>&1 && echo "‚úì HTTP (8002)" || echo "‚úó"

            echo -n "  LiveKit: "
            curl -s http://localhost:7880/ > /dev/null 2>&1 && echo "‚úì (7880)" || echo "‚úó"
          EOF

      - name: Generate Deployment Report
        id: deployment-report
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üìä Generating deployment report..."
            cd /opt/veris-memory
            
            # Create deployment report script if it doesn't exist
            if [ ! -f "scripts/deployment-report.sh" ]; then
              echo "‚ö†Ô∏è Deployment report script not found, creating basic report..."
              
              # Create a basic report
              cat > /tmp/deployment-report.json << REPORT
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "environment": "dev",
            "server": "$(hostname)",
            "containers": {
              "running": $(docker ps --filter "name=veris-memory-dev" --format "{{.Names}}" | wc -l),
              "list": $(docker ps --filter "name=veris-memory-dev" --format "{{json .Names}}" | jq -s .)
            },
            "services": {
              "api": $(curl -sf http://localhost:8000/health > /dev/null 2>&1 && echo '"healthy"' || echo '"unhealthy"'),
              "qdrant": $(curl -sf http://localhost:6333/ > /dev/null 2>&1 && echo '"healthy"' || echo '"unhealthy"'),
              "neo4j": $(timeout 2 bash -c "</dev/tcp/localhost/7687" 2>/dev/null && echo '"healthy"' || echo '"unhealthy"'),
              "redis": $(docker inspect --format='{{.State.Health.Status}}' veris-memory-dev-redis-1 2>/dev/null | grep -q "healthy" && echo '"healthy"' || echo '"unhealthy"')
            },
            "success": true
          }
          REPORT
              cat /tmp/deployment-report.json
            else
              # Run the full deployment report
              chmod +x scripts/deployment-report.sh
              ./scripts/deployment-report.sh dev
              
              # Output the latest report
              if [ -f "/tmp/deployment-report-dev.json" ]; then
                cat /tmp/deployment-report-dev.json
              fi
            fi
            
            # Save report for artifact upload
            mkdir -p /opt/veris-memory/deployment-reports
            cp /tmp/deployment-report*.json /opt/veris-memory/deployment-reports/ 2>/dev/null || true
          EOF
          
      - name: Run Dev Smoke Tests
        continue-on-error: true
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -i ~/.ssh/id_ed25519 ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            echo "üß™ Running smoke tests on DEV environment..."
            cd /opt/veris-memory
            
            # Dev uses standard ports (dual-service architecture)
            MCP_URL="http://localhost:8000"
            API_URL="http://localhost:8001"
            QDRANT_URL="http://localhost:6333"
            NEO4J_URL="http://localhost:7474"
            echo "Testing dev environment with dual-service architecture..."
            echo "  MCP Server: $MCP_URL"
            echo "  REST API: $API_URL"
            
            # Run smoke tests if available
            if [ -f "ops/smoke/smoke_runner.py" ]; then
              python3 ops/smoke/smoke_runner.py \
                --api-url "$API_URL" \
                --qdrant-url "$QDRANT_URL" \
                --neo4j-url "$NEO4J_URL" \
                --timeout 30 || echo "‚ö†Ô∏è Some smoke tests failed (non-blocking)"
            else
              echo "‚ö†Ô∏è Smoke test runner not found, skipping tests"
            fi
          EOF

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_ed25519

      - name: Notify Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Development deployment successful!"
            echo "üîµ Environment: DEV"
            echo "üåê Server: ${{ secrets.HETZNER_HOST }}"
            echo "üìç Location: /opt/veris-memory"
            echo ""
            echo "üìù Note: Production deployment requires manual intervention"
          else
            echo "‚ùå Development deployment failed!"
            echo "Please check the logs for details"
          fi